## CPP-Practice
### 函数重载：
同一作用域内，允许声明几个同名函数，它们的形参列表必须不同（参数个数、类型或顺序）
重载底层：表面上函数名是一样的，但是在编译过程中，编译器会重新修饰函数名，会将返回值类型、参数个数类型和顺序都编写到函数名上。

### 为什么C语言不支持函数重载：
因为C++重载的底层其实是在编译过程中，编译器会按照返回值和参数类型个数顺序的不同重新修饰函数名，而C语言的函数名修改规则仅仅是在函数面前加下划线，所以不支持。

### extern “C”：
有时候需要将某些函数按照C风格来编译，在函数前加上extern"C"，告诉编译器将该函数按照C语言规则来编译。

### 传值和传引用：
传值本质是传一份临时拷贝，所以效率低，尤其是传的值是一个非常大的类型的时候。
而传引用相当于传地址。

### inline内联函数：
1.inline只是一种建议，如果代码过长，编译器会忽略inline
2.定义在Class声明内的成员函数默认是inline函数

### 宏的优缺点？C++如何代替宏？：
宏的优缺点，增强了代码的复用性，提高了性能。但是代码可读性差，不方便调试（因为预编译阶段进行了替换）
C++如何代替宏：1.常量定义，换用const。 2.函数定义，换用内联函数

### 引用和指针的区别：
引用是某块内存的别名，指针本身是一个地址，这个地址指向一块内存
1.引用必须初始化，指针不用
2.引用不能为NULL，指针可以
3.引用在初始化的时候引用一个实体后，不能引用别的实体，指针可以随时指向别的内存。
4.引用访问实体不需要解引用，编译器会处理，指针需要解引用*
5.引用没有const，指针有
6.sizeof引用得到引用所指对象或变量的大小，而sizeof指针得到该指针类型的大小
7.内存分配上：程序为指针变量分配内存空间，而引用不需要分配内存空间
8.引用++，实体+1，指针++，向后偏移一个指针类型的大小
底层上：查看汇编代码，引用也是通过指针实现的

### 封装是什么？好处是？：
封装的本质是一种管理行为，只让可信的类或对象访问。好处是保护了数据。

### class和struct区别：
因为要兼容C语言，C++中struct可以定义结构体，也可以定义类，定义类的时候跟class用法相同，但是默认权限不同，class默认private，struct默认public。

### 类的大小计算 空类的大小
成员函数放在代码公共段，类的大小只包括成员变量。
空类：编译器给了空类一个字节来标识这个类

### 内存对齐：
为什么要内存对齐：如果是32位机器，编译器希望按照四个字节四个字节读取数据，如果没有对齐，一次可以读到的数据要读取两次。
对齐数：默认对齐数和当前类型大小的较小值 vs默认8
对齐规则： ①首类型放在偏移量为0地址处 此时地址为x ②x必须是下一个数据的对齐数的整数倍 ③最后整个结构体需要对齐 是最大类型大小的整数倍

### 大小端如何判断：
小小小，低字节放低地址是小端。
如何判断：int i = 1，然后拿一个char*的指针去取，char*只能取前一个字节，如果取到1，就说明低字节放在低地址了，是小端，否则是大端
int main(){
	int i=1;
	char *b=(char*)&i;
	if(*b==1){
		printf("little\n");
	}else{
		printf("big\n");
	}
	return 0;
}


### this指针：
1.this指针是除了构造函数每个成员函数都有的一个隐含的指针形参，它指向调用该成员函数的那个对象。
2.本质是一个形参，成员函数被对象调用时被创建，this指针指向当前调用这个函数的对象的地址，所以对象中不存储this指针。
3.类型：类类型* const 意味着不能给this指针赋值
4.只能在成员函数内部使用
5.this指针存在栈上


### const：
1.在成员函数后面加const，const修饰this指针所指向的对象，也就是保证调用这个const成员函数的对象在函数内不会被改变
2.const对象可以调用其他的const函数，const成员函数内可以调用其他const成员函数。
3.非const对象可以调用其他非const成员函数和const成员函数，非const成员函数内可以调用其他非const成员函数和const成员函数。
https://www.cnblogs.com/dhls231/p/Const.html

### static成员：
静态成员变量存在静态数据区
静态成员变量必须在类外初始化
静态成员全局只有一个，所有类对象共享
静态成员函数：1.没有this指针 2.函数内部不能调用非静态成员函数 3.非静态成员函数可以调用静态成员函数

### 友元的利弊，在重载中的使用：
友元分为友元函数和友元类。
友元函数：可以突破封装，访问对象的私有成员。提供了便利，但是破坏了封装，所以友元不能多用
重载时的用途：重载<<,>>的时候，因为cout会和隐含的this指针一起抢占第一个参数，如果定义成全局函数，类外又无法访问，所以
定义成友元函数可以解决。

### 什么是内部类：
一个类定义在一个类内部，就是内部类，内部类是外部类的友元类，具有友元类的一切特性，但是外部类不是内部类的友元
sizeof(外部类)=外部类，和内部类大小无关

### C/C++内存区域划分：
1.栈又叫堆栈，非静态局部变量/函数参数/返回值等等，栈是向下增长的。
2.内存映射段是高效的I/O映射方式，用于装载一个共享的动态内存库。用户可使用系统接口创建共享共享内存，做进程间通信。
3.堆用于程序运行时动态内存分配，堆是可以上增长的。
4.数据段–存储全局数据和静态数据。//多数地方叫作全局数据区或者静态区。
5.代码段–可执行的代码/只读常量。

### C语言内存管理：
malloc
calloc：申请空间，按字节初始化为0
realloc：1.原始空间如果小于申请的空间，并且原始空间有富裕的空间满足，直接修改底层标记信息，否则重新申请一块更大的空间，拷贝原有空间的内容，释放原有空间。
2.原始空间大于重新申请的空间，直接修改底层标记信息。

### C++的new和delete：
1.在申请自定义类型的空间时，new会调用构造函数，delete会调用析构函数，malloc和free不会
2.申请释放单个空间，用new和delete，申请释放连续的空间，用new[]和delete[]。
3.new是先执行operator new申请空间，然后调用构造函数初始化对象。
4.delete是先调用析构函数完成对象的资源清理工作，然后调用operator delete释放空间。

### new和delete的底层：
1.new和delete是操作符，而operator new和operator delete是系统底层提供的全局函数，new和delete底层调用这两个全局函数申请和释放内存。
2.operator new和operator delete底层调用malloc和free。
3.operator new调用malloc申请空间，成功了就直接返回，申请失败就执行用户提供的空间不足应对措施，如果用户提供该措施就继续申请，如果不提供就抛异常bad_alloc

### new[] 和 delete[] 的原理：
1.new[]底层调用operator new[]，而operator new[]实际调用operator new完成N个空间的申请，然后调用N次构造函数完成初始化。
2.delete[]调用N次析构函数完成N个对象的资源清理，然后底层调用operator delete[]，实际operator delete[]调用operator delete完成N个空间的释放。

### malloc/free和new/delete的区别：
1.new/delete是操作符可以重载，malloc/free是库函数。
2.new/delete调用构造函数/析构函数，malloc/free不会。

