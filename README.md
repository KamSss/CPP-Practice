## CPP-Practice
### 函数重载：
同一作用域内，允许声明几个同名函数，它们的形参列表必须不同（参数个数、类型或顺序）
重载底层：表面上函数名是一样的，但是在编译过程中，编译器会重新修饰函数名，会将返回值类型、参数个数类型和顺序都编写到函数名上。

### 为什么C语言不支持函数重载：
因为C++重载的底层其实是在编译过程中，编译器会按照返回值和参数类型个数顺序的不同重新修饰函数名，而C语言的函数名修改规则仅仅是在函数面前加下划线，所以不支持。

### extern “C”：
有时候需要将某些函数按照C风格来编译，在函数前加上extern"C"，告诉编译器将该函数按照C语言规则来编译。

### 传值和传引用：
传值本质是传一份临时拷贝，所以效率低，尤其是传的值是一个非常大的类型的时候。
而传引用相当于传地址。

### inline内联函数：
1.inline只是一种建议，如果代码过长，编译器会忽略inline
2.定义在Class声明内的成员函数默认是inline函数

### 宏的优缺点？C++如何代替宏？：
宏的优缺点，增强了代码的复用性，提高了性能。但是代码可读性差，不方便调试（因为预编译阶段进行了替换）
C++如何代替宏：1.常量定义，换用const。 2.函数定义，换用内联函数

### 引用和指针的区别：
引用是某块内存的别名，指针本身是一个地址，这个地址指向一块内存
1.引用必须初始化，指针不用
2.引用不能为NULL，指针可以
3.引用在初始化的时候引用一个实体后，不能引用别的实体，指针可以随时指向别的内存。
4.引用访问实体不需要解引用，编译器会处理，指针需要解引用*
5.引用没有const，指针有
6.sizeof引用得到引用所指对象或变量的大小，而sizeof指针得到该指针类型的大小
7.内存分配上：程序为指针变量分配内存空间，而引用不需要分配内存空间
8.引用++，实体+1，指针++，向后偏移一个指针类型的大小
底层上：查看汇编代码，引用也是通过指针实现的

### 封装是什么？好处是？：
封装的本质是一种管理行为，只让可信的类或对象访问。好处是保护了数据。

### class和struct区别：
因为要兼容C语言，C++中struct可以定义结构体，也可以定义类，定义类的时候跟class用法相同，但是默认权限不同，class默认private，struct默认public。

### 类的大小计算 空类的大小
成员函数放在代码公共段，类的大小只包括成员变量。
空类：编译器给了空类一个字节来标识这个类

### 内存对齐：
为什么要内存对齐：如果是32位机器，编译器希望按照四个字节四个字节读取数据，如果没有对齐，一次可以读到的数据要读取两次。
对齐数：默认对齐数和当前类型大小的较小值 vs默认8
对齐规则： ①首类型放在偏移量为0地址处 此时地址为x ②x必须是下一个数据的对齐数的整数倍 ③最后整个结构体需要对齐 是最大类型大小的整数倍

### 大小端如何判断：
小小小，低字节放低地址是小端。
如何判断：int i = 1，然后拿一个char*的指针去取，char*只能取前一个字节，如果取到1，就说明低字节放在低地址了，是小端，否则是大端
int main(){
	int i=1;
	char *b=(char*)&i;
	if(*b==1){
		printf("little\n");
	}else{
		printf("big\n");
	}
	return 0;
}


### this指针：
1.this指针是除了构造函数每个成员函数都有的一个隐含的指针形参，它指向调用该成员函数的那个对象。
2.本质是一个形参，成员函数被对象调用时被创建，this指针指向当前调用这个函数的对象的地址，所以对象中不存储this指针。
3.类型：类类型* const 意味着不能给this指针赋值
4.只能在成员函数内部使用
5.this指针存在栈上
