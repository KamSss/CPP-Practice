## CPP-Practice
### 函数重载：
同一作用域内，允许声明几个同名函数，它们的形参列表必须不同（参数个数、类型或顺序）
重载底层：表面上函数名是一样的，但是在编译过程中，编译器会重新修饰函数名，会将返回值类型、参数个数类型和顺序都编写到函数名上。

### 为什么C语言不支持函数重载：
因为C++重载的底层其实是在编译过程中，编译器会按照返回值和参数类型个数顺序的不同重新修饰函数名，而C语言的函数名修改规则仅仅是在函数面前加下划线，所以不支持。

### extern “C”：
有时候需要将某些函数按照C风格来编译，在函数前加上extern"C"，告诉编译器将该函数按照C语言规则来编译。

### 传值和传引用：
传值本质是传一份临时拷贝，所以效率低，尤其是传的值是一个非常大的类型的时候。
而传引用相当于传地址。

### inline内联函数：
1.inline只是一种建议，如果代码过长，编译器会忽略inline
2.定义在Class声明内的成员函数默认是inline函数

### 宏的优缺点？C++如何代替宏？：
宏的优缺点，增强了代码的复用性，提高了性能。但是代码可读性差，不方便调试（因为预编译阶段进行了替换）
C++如何代替宏：1.常量定义，换用const。 2.函数定义，换用内联函数

### 引用和指针的区别：
引用是某块内存的别名，指针本身是一个地址，这个地址指向一块内存
1.引用必须初始化，指针不用
2.引用不能为NULL，指针可以
3.引用在初始化的时候引用一个实体后，不能引用别的实体，指针可以随时指向别的内存。
4.引用访问实体不需要解引用，编译器会处理，指针需要解引用*
5.引用没有const，指针有
6.sizeof引用得到引用所指对象或变量的大小，而sizeof指针得到该指针类型的大小
7.内存分配上：程序为指针变量分配内存空间，而引用不需要分配内存空间
8.引用++，实体+1，指针++，向后偏移一个指针类型的大小
底层上：查看汇编代码，引用也是通过指针实现的

### 封装是什么？好处是？：
封装的本质是一种管理行为，只让可信的类或对象访问。好处是保护了数据。

### class和struct区别：
因为要兼容C语言，C++中struct可以定义结构体，也可以定义类，定义类的时候跟class用法相同，但是默认权限不同，class默认private，struct默认public。

### 类的大小计算 空类的大小
成员函数放在代码公共段，类的大小只包括成员变量。
空类：编译器给了空类一个字节来标识这个类

### 内存对齐：
为什么要内存对齐：如果是32位机器，编译器希望按照四个字节四个字节读取数据，如果没有对齐，一次可以读到的数据要读取两次。
对齐数：默认对齐数和当前类型大小的较小值 vs默认8
对齐规则： ①首类型放在偏移量为0地址处 此时地址为x ②x必须是下一个数据的对齐数的整数倍 ③最后整个结构体需要对齐 是最大类型大小的整数倍

### 大小端如何判断：
小小小，低字节放低地址是小端。
如何判断：int i = 1，然后拿一个char*的指针去取，char*只能取前一个字节，如果取到1，就说明低字节放在低地址了，是小端，否则是大端
int main(){
	int i=1;
	char *b=(char*)&i;
	if(*b==1){
		printf("little\n");
	}else{
		printf("big\n");
	}
	return 0;
}


### this指针：
1.this指针是除了构造函数每个成员函数都有的一个隐含的指针形参，它指向调用该成员函数的那个对象。
2.本质是一个形参，成员函数被对象调用时被创建，this指针指向当前调用这个函数的对象的地址，所以对象中不存储this指针。
3.类型：类类型* const 意味着不能给this指针赋值
4.只能在成员函数内部使用
5.this指针存在栈上


### const：
1.在成员函数后面加const，const修饰this指针所指向的对象，也就是保证调用这个const成员函数的对象在函数内不会被改变
2.const对象可以调用其他的const函数，const成员函数内可以调用其他const成员函数。
3.非const对象可以调用其他非const成员函数和const成员函数，非const成员函数内可以调用其他非const成员函数和const成员函数。
https://www.cnblogs.com/dhls231/p/Const.html

### static成员：
静态成员变量存在静态数据区
静态成员变量必须在类外初始化
静态成员全局只有一个，所有类对象共享
静态成员函数：1.没有this指针 2.函数内部不能调用非静态成员函数 3.非静态成员函数可以调用静态成员函数

### 友元的利弊，在重载中的使用：
友元分为友元函数和友元类。
友元函数：可以突破封装，访问对象的私有成员。提供了便利，但是破坏了封装，所以友元不能多用
重载时的用途：重载<<,>>的时候，因为cout会和隐含的this指针一起抢占第一个参数，如果定义成全局函数，类外又无法访问，所以
定义成友元函数可以解决。

### 什么是内部类：
一个类定义在一个类内部，就是内部类，内部类是外部类的友元类，具有友元类的一切特性，但是外部类不是内部类的友元
sizeof(外部类)=外部类，和内部类大小无关

### C/C++内存区域划分：
1.栈又叫堆栈，非静态局部变量/函数参数/返回值等等，栈是向下增长的。
2.内存映射段是高效的I/O映射方式，用于装载一个共享的动态内存库。用户可使用系统接口创建共享共享内存，做进程间通信。
3.堆用于程序运行时动态内存分配，堆是可以上增长的。
4.数据段–存储全局数据和静态数据。//多数地方叫作全局数据区或者静态区。
5.代码段–可执行的代码/只读常量。

### C语言内存管理：
malloc
calloc：申请空间，按字节初始化为0
realloc：1.原始空间如果小于申请的空间，并且原始空间有富裕的空间满足，直接修改底层标记信息，否则重新申请一块更大的空间，拷贝原有空间的内容，释放原有空间。
2.原始空间大于重新申请的空间，直接修改底层标记信息。

### C++的new和delete：
1.在申请自定义类型的空间时，new会调用构造函数，delete会调用析构函数，malloc和free不会
2.申请释放单个空间，用new和delete，申请释放连续的空间，用new[]和delete[]。
3.new是先执行operator new申请空间，然后调用构造函数初始化对象。
4.delete是先调用析构函数完成对象的资源清理工作，然后调用operator delete释放空间。

### new和delete的底层：
1.new和delete是操作符，而operator new和operator delete是系统底层提供的全局函数，new和delete底层调用这两个全局函数申请和释放内存。
2.operator new和operator delete底层调用malloc和free。
3.operator new调用malloc申请空间，成功了就直接返回，申请失败就执行用户提供的空间不足应对措施，如果用户提供该措施就继续申请，如果不提供就抛异常bad_alloc

### new[] 和 delete[] 的原理：
1.new[]底层调用operator new[]，而operator new[]实际调用operator new完成N个空间的申请，然后调用N次构造函数完成初始化。
2.delete[]调用N次析构函数完成N个对象的资源清理，然后底层调用operator delete[]，实际operator delete[]调用operator delete完成N个空间的释放。

### malloc/free和new/delete的区别：
1.new/delete是操作符可以重载，malloc/free是库函数。
2.new/delete调用构造函数/析构函数，malloc/free不会。

### 继承是什么，作用是什么：
继承是面向对象的特性，它让代码或者说类层次的设计可以复用，我们在保持原有父类的特性的基础上进行扩展和增加功能，这样产生的类就叫子类。
继承之后父类的成员函数+成员变量就被子类复用变成子类的一部分。

### 三种继承方式：
1.父类的private私有成员，在子类中不可见。不可见指的是私有成员被继承到了子类，但是语法上限制了对它的访问。
2.如果父类不希望类外面直接可以访问，但是子类中又可以访问，就定义成protected成员。protected限定符可以说是因为继承才出现。
3.class默认继承是private，struct默认继承是public，但最好显式写出继承方式。
4.实际一般都是使用public继承，因为保护继承/私有继承下来的对象只能在子类中使用，限制了扩展性。

### 子类父类赋值转换：
1.子类可以赋值给父类的对象、指针、引用，又称切片操作。
2.父类不能赋值给子类（不可逆）。
3.父类指针强制类型转换之后可以赋值给子类指针，但该父类指针必须指向子类对象才安全。

### 隐藏（重定义）：
1.父类和子类中的同名成员、同名函数，子类会屏蔽对父类同名成员、同名函数的直接访问。
2.通过父类::同名成员的方式可以显式访问了。
3.实际中最好不要出现同名成员，这样的代码看起来很乱。

### 子类的四大默认成员函数：（取地址和const不需要）
1.子类的构造函数必须调用父类的构造函数初始化继承自父类的那一部分成员，而且先调父类再调子类。
2.没有写子类的构造函数，也会去调父类的默认构造函数。如果父类没有默认构造，必须在子类的初始化列表显示调用。
2.子类对象析构之前，必须先调用子类的析构函数清理子类成员，然后再调用父类的析构函数清理父类成员，后构造的先析构。

### 实现不能被继承的类：
C++11关键字final

### 友元和继承：
友元关系不能继承，也就是说基类友元不能访问子类私有和保护成员

### 继承和static成员：
父类定义了static成员，则不管有多少类继承了该父类，这个static成员都只有一份实例，被所有类共享。

### 单继承、多继承、菱形继承：
单继承：一个子类只有一个直接父类。
多继承：一个子类有多个直接父类。
菱形继承：是多继承的特殊情况，子类的多个父类的父类是同一个父类（爷爷类）。

### 菱形继承的二义性和数据冗余：
一个菱形继承的子类A，父类为B和C，B和C父类为D，BC各有一个从D继承来的E。
A访问一个从BC继承来的（BC从D继承来）的成员变量E，那么A.E到底是访问从B继承来的E还是从D继承来的E呢，这就是二义性。
解决方法：A.B::E 加上限定符就能确定是从哪个父类继承来的了。
数据冗余：这个E在A中有两份，两份分别来自父类BC从D中继承来的，这就是数据冗余。

### 虚拟继承解决二义性和数据冗余的原理：
class B：virtual public D{}
class C：virtual public D{}
1.子类对象A将E放在对象存储的最下面（低地址），E同时属于B和C。
2.BC如何找到共享的E呢，通过B和C的两个指针（虚基表指针），指向虚基表，虚基表记录的是偏移量（也就是B要找到共享E要偏移多少，C要找到E要偏移多少）
3.偏移量+当前对象地址，就可以找到共享的E了。

### 在继承中构成多态
什么是多态：多态前提是继承，多态就是针对不同继承关系的对象，去调同一个函数，产生不同的行为。
两个条件： 
1.  用函数的对象必须是指针或者引用。
	原因：如果不传指针和引用，就是值传递，会调用构造函数，
	结果只会调用父类的函数，不会构成多态（对不同对象有不同调用）
2. 被调用的函数必须是虚函数，且完成了虚函数的重写（又称覆盖 函数名 返回值 参数个数 类型都相同）。
